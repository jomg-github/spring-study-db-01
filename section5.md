# 스프링 DB 1편 - 데이터 접근 핵심 원리

## 섹션5 - 스프링과 문제해결-트랜잭션 

---

### 문제점

1. 트랜잭션 문제
   - 트랜잭션을 적용하기 위해 서비스 계층에서 JDBC 기술을 구현해야 함 (서비스 계층은 특정 라이브러리에 종속되지 않아야 함)
   - 커넥션을 서비스 메소드의 파라미터로 넘겨야 하고, 동일한 기능도 트랜잭셔널한 기능과 Non-트랜잭셔널한 기능으로 분리해야 함
   - 트랜잭션을 적용하기 위해 비지니스 로직을 try-catch-finally 코드로 감싸야 하고 중복 코드가 발생

2. 예외 누수 문제
   - Persist Layer에서 발생하는 checked exception이 서비스 계층으로 전파됨
   - SQLException은 JDBC에 종속된 예외이기 때문에 JPA 등과 같은 기술적 변화가 있을 때, 다른 예외로 변경해야 함
   

3. JDBC 반복 문제
    - 트랜잭션을 적용하기 위한 메소드에 try-catch-finally 코드가 중복 구현


### 트랜잭션 추상화

#### 문제점
- 구현 기술에 따라 트랜잭션을 사용하는 방법이 다르기 때문에 데이터 접근 라이브러리를 변경하게 되면 코드도 함께 변경해야 됨
- JDBC : `con.setAutoCommit(false)`
- JPA : `transaction.begin()`

#### 스프링 트랜잭션 추상화

- 스프링은 위 문제점을 해결하기 위해 트랜잭션을 추상화한 인터페이스를 제공함 `PlatformTransactionManager`
- `PlatformTransactionManager` 주요 메소드
  - `getTransaction()`
    - 트랜잭션을 시작
    - 기존에 이미 진행중인 트랜잭션이 있는 경우 해당 트랜잭션에 참여 가능
  - `commit()`, `rollback()`
    - 커밋과 롤백 


### 트랜잭션 동기화

스프링이 제공하는 트랜잭션 매니저는 크게 두 가지의 역할 

- 트랜잭션 추상화
- 리소스 동기화

#### 문제점

- 트랜잭션을 유지하려면 트랜잭션의 시작부터 끝까지 같은 DB 커넥션을 유지해야 함
- 파라미터로 커넥션을 전달하는 방법은 코드가 지저분해지고, 커넥션을 넘기는 메소드와 넘기지 않는 메소드를 오버로딩해서 생성해야 하는 문제

#### 스프링 트랜잭션 동기화

- 스프링의 트랜잭션 매니저는 내부적으로 ThreadLocal 기반의 트랜잭션 동기화 매니저(TransactionSynchronizationManager)를 사용함 
- ThreadLocal을 사용하기 때문에 멀티 스레드 상황에서도 안전하게 커넥션 동기화
- 동작과정
  1. 트랜잭션 매니저는 데이터 소스를 통해 커넥션을 만들고 트랜잭션 시작
  2. 트랜잭션 매니저는 트랜잭션이 시작된 커넥션을 트랜잭션 동기화 매니저에 보관
  3. 리포지토리는 트랜잭션 동기화 매니저에 보관된 커넥션을 꺼내서 사용 (파라미터로 커넥션을 주고 받지 않아도 됨)
  4. 트랜잭션이 종료되면 트랜잭션 매니저는 트랜잭션 동기화 매니저에 보관된 커넥션을 통해 트랜잭션을 종료하고 커넥션도 닫음


### 트랜잭션 템플릿

- 트랜잭션을 사용하는 로직은 같은 패턴
- 스프링은 